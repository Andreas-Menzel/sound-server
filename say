#!/usr/bin/env python3
"""
Command-line script for text-to-speech, similar to macOS 'say' command.
Uses the Piper TTS sound server API.
"""

import argparse
import sys
import urllib.request
import urllib.parse
import urllib.error
import json

DEFAULT_SERVER = "http://localhost:8000"
DEFAULT_LANG = "en"

# Default voices per language
DEFAULT_VOICES = {
    "en": "lessac",
    "de": "thorsten",
}


def say(text: str, voice: str | None = None, language: str = DEFAULT_LANG, server: str = DEFAULT_SERVER) -> bool:
    """Send text to the TTS server to be spoken."""
    # Use language default voice if no voice specified
    if not voice:
        voice = DEFAULT_VOICES.get(language)
    
    payload = {"text": text}
    if voice:
        payload["voice"] = voice

    url = f"{server}/say"

    try:
        data = json.dumps(payload).encode("utf-8")
        req = urllib.request.Request(url, data=data, method="POST")
        req.add_header("Content-Type", "application/json")
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode())
            return result.get("success", False)
    except urllib.error.HTTPError as e:
        error_body = e.read().decode()
        try:
            error_detail = json.loads(error_body).get("detail", error_body)
        except json.JSONDecodeError:
            error_detail = error_body
        print(f"Error: {error_detail}", file=sys.stderr)
        return False
    except urllib.error.URLError as e:
        print(f"Error: Could not connect to server at {server}: {e.reason}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return False


def list_voices(language: str | None = None, server: str = DEFAULT_SERVER) -> bool:
    """List available voices from the server."""
    params = {}
    if language:
        params["language"] = language
    url = f"{server}/voices"
    if params:
        url += f"?{urllib.parse.urlencode(params)}"

    try:
        with urllib.request.urlopen(url, timeout=10) as response:
            result = json.loads(response.read().decode())
            voices = result.get("voices", {})
            default = result.get("default", "")

            print("Available voices:")
            for name, meta in sorted(voices.items()):
                installed = meta.get("installed", False)
                status = "" if installed else " (not installed)"
                default_marker = " [default]" if name == default else ""
                desc = meta.get("description", "")
                print(f"  {name}: {desc}{default_marker}{status}")
            return True
    except urllib.error.URLError as e:
        print(f"Error: Could not connect to server at {server}: {e.reason}", file=sys.stderr)
        return False
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return False


def get_default_language() -> str:
    """Get the default language based on how the script was invoked."""
    import os
    script_name = os.path.basename(sys.argv[0])
    if script_name == "sage":
        return "de"
    return DEFAULT_LANG


def main():
    default_lang = get_default_language()
    
    parser = argparse.ArgumentParser(
        description="Text-to-speech command, similar to macOS 'say'",
        epilog="Examples:\n"
               "  say 'Hello, world!'\n"
               "  say -v amy 'Hello in Amy voice'\n"
               "  say -l de 'Hallo Welt'\n"
               "  echo 'Hello' | say\n"
               "  say --list-voices\n"
               "  sage 'Hallo Welt'  # German alias",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "text",
        nargs="*",
        help="Text to speak (reads from stdin if not provided)",
    )
    parser.add_argument(
        "-v", "--voice",
        help="Voice to use (see --list-voices for options)",
    )
    parser.add_argument(
        "-l", "--language",
        default=default_lang,
        help=f"Language to use: en, de (default: {default_lang})",
    )
    parser.add_argument(
        "--list-voices",
        action="store_true",
        help="List available voices and exit",
    )
    parser.add_argument(
        "-s", "--server",
        default=DEFAULT_SERVER,
        help=f"TTS server URL (default: {DEFAULT_SERVER})",
    )

    args = parser.parse_args()

    if args.list_voices:
        success = list_voices(language=args.language, server=args.server)
        sys.exit(0 if success else 1)

    # Get text from arguments or stdin
    if args.text:
        text = " ".join(args.text)
    elif not sys.stdin.isatty():
        text = sys.stdin.read().strip()
    else:
        parser.print_help()
        sys.exit(1)

    if not text:
        print("Error: No text provided", file=sys.stderr)
        sys.exit(1)

    success = say(text, voice=args.voice, language=args.language, server=args.server)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
